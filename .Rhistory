return(list(as.matrix(net_[i__, ]), r__))
}
if (nThreads_ != 1) {
deltarank = future.apply::future_lapply(1:nrow(net_), calculator_)
} else {
deltarank = lapply(1:nrow(net_), calculator_)
}
genePair = do.call(rbind, sapply(deltarank, '[', 1)) |> as.data.frame()
rankValue = do.call(cbind, sapply(deltarank, '[', 2)) |> as.data.frame()
genePair[[3]] = paste0('V', 1:nrow(genePair))
colnames(genePair) = c('from', 'to', 'ind')
rownames(rankValue) = genePair$ind
return(list(genePair, rankValue))
}
library(tidyverse)
data_test = read.csv('data/inputMatTest.csv', row.names = 'symbol')[1:2000, ]
net_reactome = read.csv('data/reactome.csv')
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_control_
}
}
trans2GI(data_test, controlMat_ = data_test)
rank.matrix = function(mat_) {
rankmatrix = c()
for (i in 1: ncol(mat_)){
temp = rank(mat_[, i])
rankmatrix = cbind(rankmatrix, temp)
}
colnames(rankmatrix) = colnames(mat_)
rownames(rankmatrix) = rownames(mat_)
return(rankmatrix)
}
delta.rank = function(mat_, net_, nThreads_ = 1) {
mat_ = rank.matrix(mat_)
calculator_ = function(i__) {
r1__ = which(rownames(mat_) == net_[[1]][i__])
r2__ = which(rownames(mat_) == net_[[2]][i__])
r__  = mat_[r1__, ] - mat_[r2__, ]
return(list(as.matrix(net_[i__, ]), r__))
}
if (nThreads_ != 1) {
deltarank = future.apply::future_lapply(1:nrow(net_), calculator_)
} else {
deltarank = lapply(1:nrow(net_), calculator_)
}
genePair = do.call(rbind, sapply(deltarank, '[', 1)) |> as.data.frame()
rankValue = do.call(cbind, sapply(deltarank, '[', 2)) |> as.data.frame()
genePair[[3]] = paste0('V', 1:nrow(genePair))
# colnames(genePair) = c('from', 'to', 'ind')
#
# rownames(rankValue) = genePair$ind
return(list(genePair, rankValue))
}
library(tidyverse)
data_test = read.csv('data/inputMatTest.csv', row.names = 'symbol')[1:2000, ]
net_reactome = read.csv('data/reactome.csv')
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_control_
}
}
trans2GI(data_test, controlMat_ = data_test)
source("F:/0Local/project/transGI/R/main.R", echo=TRUE)
rank.matrix = function(mat_) {
rankmatrix = c()
for (i in 1: ncol(mat_)){
temp = rank(mat_[, i])
rankmatrix = cbind(rankmatrix, temp)
}
colnames(rankmatrix) = colnames(mat_)
rownames(rankmatrix) = rownames(mat_)
return(rankmatrix)
}
delta.rank = function(mat_, net_, nThreads_ = 1) {
mat_ = rank.matrix(mat_)
calculator_ = function(i__) {
r1__ = which(rownames(mat_) == net_[[1]][i__])
r2__ = which(rownames(mat_) == net_[[2]][i__])
r__  = mat_[r1__, ] - mat_[r2__, ]
return(list(as.matrix(net_[i__, ]), r__))
}
if (nThreads_ != 1) {
deltarank = future.apply::future_lapply(1:nrow(net_), calculator_)
} else {
deltarank = lapply(1:nrow(net_), calculator_)
}
genePair = do.call(rbind, sapply(deltarank, '[', 1)) |> as.data.frame()
rankValue = do.call(cbind, sapply(deltarank, '[', 2)) |> as.data.frame()
genePair[[3]] = paste0('V', 1:nrow(genePair))
# colnames(genePair) = c('from', 'to', 'ind')
#
# rownames(rankValue) = genePair$ind
return(list(genePair, rankValue))
}
source("F:/0Local/project/transGI/R/main.R", echo=TRUE)
debugSource("F:/0Local/project/transGI/R/deltarank.R", echo=TRUE)
devtools::load_all()
source("F:/0Local/project/transGI/R/main.R", echo=TRUE)
debugSource("F:/0Local/project/transGI/R/main.R", echo=TRUE)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
View(res_)
View(res_[[2]])
debugSource("F:/0Local/project/transGI/R/main.R", echo=TRUE)
res_control_
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_control_
View()
View(res_control_)
View(res_control_[[2]])
res_[[2]] - res_control_[[2]]
unlist(res_control_[[2]])
res_[[2]] |>
apply(1, \(vec__) vec__  - unlist(res_control_[[2]]))
as.matrix(res_[[2]]) - unlist(res_control_[[2]])
as.matrix(res_[[2]]) - unlist(res_control_[[2]]) |>
View()
x = as.matrix(res_[[2]]) - unlist(res_control_[[2]])
View(x)
View(res[[2]])
View(res_[[2]])
rep(unlist(res_control_[[2]]), each = 9)
matrix(rep(unlist(res_control_[[2]]), each = 9), nrow = 9)
matrix(rep(unlist(res_control_[[2]]), each = 9), nrow = 9) |> View()
as.matrix(res_[[2]]) - matrix(rep(unlist(res_control_[[2]]), each = nrow(res_[[2]])), nrow = nrow(res_[[2]]))
matrix(1:4, nrow = 2)[[2]]
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_[[2]] = res_[[2]] - matrix(rep(unlist(res_control_[[2]]), each = nrow(res_[[2]])), nrow = nrow(res_[[2]]))
}
names(res_) = c('genepair', 'converted')
res_ = lapply(res_, as.data.frame)
return(res_)
}
devtools::load_all()
library(tidyverse)
data_test = read.csv('data/inputMatTest.csv', row.names = 'symbol')[1:2000, ]
net_reactome = read.csv('data/reactome.csv')
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_[[2]] = res_[[2]] - matrix(rep(unlist(res_control_[[2]]), each = nrow(res_[[2]])), nrow = nrow(res_[[2]]))
}
names(res_) = c('genepair', 'converted')
res_ = lapply(res_, as.data.frame)
return(res_)
}
trans2GI(data_test, controlMat_ = data_test)
devtools::load_all()
rank.matrix = function(mat_) {
rankmatrix = c()
for (i in 1: ncol(mat_)){
temp = rank(mat_[, i])
rankmatrix = cbind(rankmatrix, temp)
}
colnames(rankmatrix) = colnames(mat_)
rownames(rankmatrix) = rownames(mat_)
return(rankmatrix)
}
delta.rank = function(mat_, net_, nThreads_ = 1) {
mat_ = rank.matrix(mat_)
calculator_ = function(i__) {
r1__ = which(rownames(mat_) == net_[[1]][i__])
r2__ = which(rownames(mat_) == net_[[2]][i__])
r__  = mat_[r1__, ] - mat_[r2__, ]
return(list(as.matrix(net_[i__, ]), r__))
}
if (nThreads_ != 1) {
deltarank = future.apply::future_lapply(1:nrow(net_), calculator_)
} else {
deltarank = lapply(1:nrow(net_), calculator_)
}
genePair = do.call(rbind, sapply(deltarank, '[', 1))
rankValue = do.call(cbind, sapply(deltarank, '[', 2))
genePair[, 3] = paste0('V', 1:nrow(genePair))
return(list(genePair, rankValue))
}
source("F:/0Local/project/transGI/R/main.R", echo=TRUE)
View(genePair)
genePair[, 3]
matrix(1:4, nrow = 2)
matrix(1:4, nrow = 2)[, 3]
devtools::load_all()
library(tidyverse)
data_test = read.csv('data/inputMatTest.csv', row.names = 'symbol')[1:2000, ]
net_reactome = read.csv('data/reactome.csv')
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_[[2]] = res_[[2]] - matrix(rep(unlist(res_control_[[2]]), each = nrow(res_[[2]])), nrow = nrow(res_[[2]]))
}
names(res_) = c('genepair', 'converted')
res_ = lapply(res_, as.data.frame)
return(res_)
}
trans2GI(data_test, controlMat_ = data_test)
rank.matrix = function(mat_) {
rankmatrix = c()
for (i in 1: ncol(mat_)){
temp = rank(mat_[, i])
rankmatrix = cbind(rankmatrix, temp)
}
colnames(rankmatrix) = colnames(mat_)
rownames(rankmatrix) = rownames(mat_)
return(rankmatrix)
}
delta.rank = function(mat_, net_, nThreads_ = 1) {
mat_ = rank.matrix(mat_)
calculator_ = function(i__) {
r1__ = which(rownames(mat_) == net_[[1]][i__])
r2__ = which(rownames(mat_) == net_[[2]][i__])
r__  = mat_[r1__, ] - mat_[r2__, ]
return(list(as.matrix(net_[i__, ]), r__))
}
if (nThreads_ != 1) {
deltarank = future.apply::future_lapply(1:nrow(net_), calculator_)
} else {
deltarank = lapply(1:nrow(net_), calculator_)
}
genePair = do.call(rbind, sapply(deltarank, '[', 1))
rankValue = do.call(cbind, sapply(deltarank, '[', 2))
genePair = cbind(genePair, paste0('V', 1:nrow(genePair)))
return(list(genePair, rankValue))
}
library(tidyverse)
data_test = read.csv('data/inputMatTest.csv', row.names = 'symbol')[1:2000, ]
net_reactome = read.csv('data/reactome.csv')
trans2GI = function(testMat_, method_ = 'deltarank', bgNet_ = 'reactome', nThreads_ = 1, maskMat_ = NULL, controlMat_ = NULL) {
match.arg(method_, c('deltarank', 'pairwise'))
if (is.character(bgNet_)) {
match.arg(bgNet_, c('reactome', 'string'))
bgNet_ = read.csv(file.path('data', paste0(bgNet_, '.csv')))
}
bgNet_ = bgNet_[(bgNet_[[1]] %in% rownames(testMat_)) & (bgNet_[[2]] %in% rownames(testMat_)), ]
if (nrow(bgNet_) == 0) stop('pity')
# testMat_ = testMat_[unique(c(bgNet_[[1]], bgNet_[[2]])), ]
future::plan('multisession', workers = nThreads_)
res_ = switch(
method_,
"deltarank" = delta.rank(testMat_, bgNet_, nThreads_),
"pairwise"  = pair.wise(testMat_, bgNet_, nThreads_)
)
future::plan('sequential')
if (!is.null(controlMat_)) {
controlMat_ = controlMat_ |>
apply(1, mean) |>
as.matrix()
colnames(controlMat_) = 'meanPerturbation'
res_control_ = switch(
method_,
"deltarank" = delta.rank(controlMat_, bgNet_),
"pairwise"  = pair.wise(controlMat_, bgNet_)
)
res_[[2]] = res_[[2]] - matrix(rep(unlist(res_control_[[2]]), each = nrow(res_[[2]])), nrow = nrow(res_[[2]]))
}
names(res_) = c('genepair', 'converted')
res_ = lapply(res_, as.data.frame)
return(res_)
}
trans2GI(data_test, controlMat_ = data_test)
library(transGI)
trans2GI(data_test)
setwd('~')
trans2GI(data_test)
system.file()
system.file(package = 'transGI')
Rdata <- readRDS("G:/R-4.3.1/library/transGI/data/Rdata.rds")
View(Rdata)
library(transGI)
system.file("extdata", package = "transGI")
system.file("extdata", package = "transGI")
library(transGI)
system.file("extdata", "reactome.csv", package = "transGI")
system.file("extdata", "reactome.csv", package = "transGI") |> read.csv()
trans2GI(data_test)
devtools::load_all()
setwd('F:/0Local')
setwd('./project/transGI/')
devtools::load_all()
library(transGI)
trans2GI(data_test)
transGI::trans2GI
transGI::trans2GI(data_test)
net_string = read_tsv('inst/extdata/string.txt')
View(net_string)
net_string = read_delim('inst/extdata/string.txt', delim = ' ')
View(net_string)
net_string$combined_score |> hist()
net_string_converted = net_string |>
filter(combined_score > 300)
net_string_converted = net_string |>
filter(combined_score > 300) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ str_sub(.x, 6)))
View(net_string_converted)
net_string_converted = net_string |>
filter(combined_score > 400) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ str_sub(.x, 6)))
net_string_converted = net_string |>
filter(combined_score > 500) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ str_sub(.x, 6)))
library(clusterProfiler)
bitr(net_string_converted$protein1,fromType = 'ENSEMBL',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db')
x = bitr(net_string_converted$protein1,fromType = 'ENSEMBLA',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db')
x = bitr(net_string_converted$protein1,fromType = 'ENSEMBLPROT',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db')
View(x)
table_E2S = bitr(
unique(c(net_string_converted$protein1, net_string_converted$protein2)),
fromType = 'ENSEMBLPROT',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db'
)
table_E2S = bitr(
unique(c(net_string$protein1, net_string$protein2)),
fromType = 'ENSEMBLPROT',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db'
)
table_E2S = bitr(
unique(c(net_string$protein1, net_string$protein2)) |> str_sub(start = 6),
fromType = 'ENSEMBLPROT',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db'
)
View(table_E2S)
table_E2S = bitr(
unique(c(net_string$protein1, net_string$protein2)) |> str_sub(start = 6),
fromType = 'ENSEMBLPROT',toType = 'SYMBOL',OrgDb = 'org.Hs.eg.db'
) |> pull(SYMBOL, ENSEMBLPROT)
net_string_converted = net_string |>
filter(combined_score > 500) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ table_E2S[str_sub(.x, 6)]))
View(net_string_converted)
net_string_converted = net_string |>
filter(combined_score > 500) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ table_E2S[str_sub(.x, 6)])) |>
drop_na()
View(net_string_converted)
net_string_converted = net_string |>
filter(combined_score > 400) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ table_E2S[str_sub(.x, 6)])) |>
drop_na()
net_string_converted = net_string |>
filter(combined_score > 400) |>
select(protein1, protein2) |>
mutate(across(everything(), ~ table_E2S[str_sub(.x, 6)])) |>
drop_na() |>
set_names(c('X1', 'X2'))
write_csv(net_string_converted, 'inst/extdata/string.csv')
devtools::load_all()
library(transGI)
usethis::use_readme_rmd()
grepl('a', c('abc', 'bc'))
?ggmonika::pal_monika
devtools::load_all()
library(transGI)
?transGI::transGI
devtools:::document()
library(transGI)
?transGI::transGI
?ggsci::pal_aaas
devtools:::document()
?transGI::transGI
pkgload::dev_help('delta.rank')
devtools:::document()
library(transGI)
?transGI::transGI
system.file('transGI')
system.file('transGI', package = 'transGI')
system.file('extdata', package = 'transGI')
system.file('extdata', package = 'transGI') |> list.files()
system.file('extdata', 'inputMatTest.csv', package = 'transGI')
testMat_ = system.file('extdata', 'inputMatTest.csv', package = 'transGI') |>
read.csv(row.names = 'symbol') |>
as.matrix()
devtools:::document()
library(transGI)
?transGI::transGI
devtools:::document()
library(transGI)
?transGI::transGI
devtools:::document()
library(transGI)
